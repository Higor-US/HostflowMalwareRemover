package haizivs.hostflowmalwareremover;

import lombok.Cleanup;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TypeInsnNode;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

public class HostflowRemover {

    private static final String PREFIX = "[HostflowMalwareRemover] ";

    private final ArrayList<Path> infectedFiles = new ArrayList<>();

    public static void main(String[] args) {
        Path plugins = FileSystems.getDefault().getPath("plugins");
        if (Files.exists(plugins)) {
            new HostflowRemover(plugins);
        } else {
            System.out.println(PREFIX + "Could not find 'plugins' directory.");
        }
    }

    public HostflowRemover(Path pluginsPath) {
        try {
            Files.walk(pluginsPath).forEach(path -> scanFile(path.toFile()));

            if (!infectedFiles.isEmpty()) {
                System.err.println(PREFIX + String.format("Found %d plugins with malware. Removing...", infectedFiles.size()));

                File pluginsFile = pluginsPath.toFile();
                File quarantine = new File(pluginsFile, "malware-quarantine");

                for (Path path : infectedFiles) {
                    File file = path.toFile();
                    File from = new File(quarantine, file.getName());
                    File to = new File(pluginsFile, file.getName());
                    if (!file.renameTo(from)) {
                        System.err.println(PREFIX + "Could not move malware to quarantine.");
                        return;
                    }

                    System.out.println(PREFIX + "Removing malware from " + from.getName() + "...");
                    try {
                        runRemover(from, to);
                    } catch (Throwable e) {
                        e.printStackTrace();
                        System.err.println(PREFIX + "Could not remove malware from " + from.getName() + ".");
                    }
                }
            } else {
                System.out.println(PREFIX + "No plugins with malware were found.");
            }
            System.out.println(PREFIX + "Done!");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void scanFile(File file) {
        if (file.isDirectory()) {
            return;
        }

        String fileName = file.getName();
        if (!fileName.endsWith(".jar")) {
            return;
        }

        try {
            @Cleanup ZipFile zip = new ZipFile(file);
            Enumeration<? extends ZipEntry> entries = zip.entries();
            while (entries.hasMoreElements()) {
                ZipEntry zipEntry = entries.nextElement();
                zipEntry.setCompressedSize(-1);
                if (zipEntry.getName().equals("javassist/PingMessage.class")
                        || zipEntry.getName().equals("javassist/ResponseContainer.class")) {
                    infectedFiles.add(file.toPath());
                    break;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println(PREFIX + "Failed to scan " + fileName);
        }
    }

    private void runRemover(File from, File to) throws Exception {
        ArrayList<String> ignoreOnOutput = new ArrayList<>();
        @Cleanup ZipOutputStream out = new ZipOutputStream(new FileOutputStream(to));
        @Cleanup ZipFile zipFile = new ZipFile(from);

        Enumeration<? extends ZipEntry> entries = zipFile.entries();
        while (entries.hasMoreElements()) {
            ZipEntry zipEntry = entries.nextElement();
            zipEntry.setCompressedSize(-1);
            if (zipEntry.getName().endsWith("module-info.class")) {
                continue;
            }

            String entryName = zipEntry.getName();
            if (!entryName.endsWith(".class")) {
                if (entryName.equals(".l1") || entryName.equals(".l_ignore") || entryName.startsWith("javassist/")) {
                    continue;
                }
                out.putNextEntry(zipEntry);
                FileUtils.writeToFile(out, zipFile.getInputStream(zipEntry));
                continue;
            }

            @Cleanup InputStream in = zipFile.getInputStream(zipEntry);

            ClassReader cr = new ClassReader(in);
            ClassNode classNode = new ClassNode();
            cr.accept(classNode, 0);

            if (classNode.superName.equals("org/bukkit/plugin/java/JavaPlugin")) {
                for (MethodNode mn : classNode.methods) {
                    if (!mn.name.equals("onEnable")) {
                        continue;
                    }

                    List<AbstractInsnNode> remove = new CopyOnWriteArrayList<>();
                    for (AbstractInsnNode insn : mn.instructions) {
                        if (!(insn instanceof TypeInsnNode)) {
                            continue;
                        }

                        TypeInsnNode tinsn = (TypeInsnNode) insn;
                        if (tinsn.desc.equals(classNode.name + "L10")) {
                            ignoreOnOutput.add(classNode.name + "L10.class");
                            remove.add(insn);
                            remove.add(AsmUtils.getNext(insn, 1));
                            remove.add(AsmUtils.getNext(insn, 2));
                            remove.add(AsmUtils.getNext(insn, 3));
                            remove.add(AsmUtils.getNext(insn, 4));
                            remove.add(AsmUtils.getNext(insn, 5));
                            remove.add(AsmUtils.getNext(insn, 6));
                        }
                    }
                    remove.forEach(ainsn -> mn.instructions.remove(ainsn));
                }
            }

            ClassWriter cw = new ClassWriter(1);
            classNode.accept(cw);

            ZipEntry newEntry = new ZipEntry(entryName);
            if (!ignoreOnOutput.contains(entryName) && !entryName.startsWith("javassist/")) {
                out.putNextEntry(newEntry);
                @Cleanup ByteArrayInputStream bais = new ByteArrayInputStream(cw.toByteArray());
                FileUtils.writeToFile(out, bais);
            }
        }
    }

}
